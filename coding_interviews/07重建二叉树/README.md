## 07重建二叉树

```
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出
    前序遍历 preorder = [3,9,20,15,7]
    中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
 
限制：
    0 <= 节点个数 <= 5000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

### 官方思路

```
    二叉树的前序遍历顺序是：根节点/左子树/右子树，每个子树的遍历顺序同样满足前序遍历顺序
    二叉树的中序遍历顺序是：左子树/根节点/右子树，每个子树的遍历顺序同样满足中序遍历顺序

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历的位置，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，有此可知左子树和右子树分别有多少节点
树中的节点数量和遍历方式无关，通过中序遍历得知左子树和右子树的节点数量之后，可以根据节点数量得到前序遍历中的左子树和右子树的分解，因此可以进一步通过左子树和右子树各自的前序遍历和中序遍历，可以通过递归方式，重建左子树和右子树，然后重建整个二叉树

T: O(n)。对于每个节点都有创建过程以及根据左右子树重建过程。
S: O(n)。存储整棵树的开销。
```